diff -Naur gcc-6.2.0.orig/gcc/graphite-isl-ast-to-gimple.c gcc-6.2.0/gcc/graphite-isl-ast-to-gimple.c
--- gcc-6.2.0.orig/gcc/graphite-isl-ast-to-gimple.c	2016-12-09 13:12:37.722083855 -0800
+++ gcc-6.2.0/gcc/graphite-isl-ast-to-gimple.c	2016-12-09 13:12:48.138131239 -0800
@@ -2493,9 +2493,6 @@
       tree res = gimple_phi_result (phi);
       if (virtual_operand_p (res))
 	continue;
-      if (is_gimple_reg (res) && scev_analyzable_p (res, region->region))
-	/* Cond phi nodes should not be scev_analyzable_p.  */
-	gcc_unreachable ();
 
       gphi *new_phi = create_phi_node (SSA_NAME_VAR (res), new_bb);
       tree new_res = create_new_def_for (res, new_phi,
diff -Naur gcc-6.2.0.orig/gcc/ipa-comdats.c gcc-6.2.0/gcc/ipa-comdats.c
--- gcc-6.2.0.orig/gcc/ipa-comdats.c	2016-12-09 13:12:37.733083905 -0800
+++ gcc-6.2.0/gcc/ipa-comdats.c	2016-12-09 13:12:48.139131244 -0800
@@ -416,7 +416,7 @@
 bool
 pass_ipa_comdats::gate (function *)
 {
-  return optimize;
+  return HAVE_COMDAT_GROUP && optimize;
 }
 
 } // anon namespace
diff -Naur gcc-6.2.0.orig/gcc/match.pd gcc-6.2.0/gcc/match.pd
--- gcc-6.2.0.orig/gcc/match.pd	2016-12-09 13:12:30.819052452 -0800
+++ gcc-6.2.0/gcc/match.pd	2016-12-09 13:12:48.140131248 -0800
@@ -828,33 +828,6 @@
   (op:c truth_valued_p@0 (logical_inverted_value @0))
   { constant_boolean_node (op == NE_EXPR ? true : false, type); }))
 
-/* If arg1 and arg2 are booleans (or any single bit type)
-   then try to simplify:
-
-   (~X & Y) -> X < Y
-   (X & ~Y) -> Y < X
-   (~X | Y) -> X <= Y
-   (X | ~Y) -> Y <= X
-
-   But only do this if our result feeds into a comparison as
-   this transformation is not always a win, particularly on
-   targets with and-not instructions.
-   -> simplify_bitwise_binary_boolean */
-(simplify
-  (ne (bit_and:c (bit_not @0) @1) integer_zerop)
-  (if (INTEGRAL_TYPE_P (TREE_TYPE (@1))
-       && TYPE_PRECISION (TREE_TYPE (@1)) == 1)
-   (if (TYPE_UNSIGNED (TREE_TYPE (@1)))
-    (lt @0 @1)
-    (gt @0 @1))))
-(simplify
-  (ne (bit_ior:c (bit_not @0) @1) integer_zerop)
-  (if (INTEGRAL_TYPE_P (TREE_TYPE (@1))
-       && TYPE_PRECISION (TREE_TYPE (@1)) == 1)
-   (if (TYPE_UNSIGNED (TREE_TYPE (@1)))
-    (le @0 @1)
-    (ge @0 @1))))
-
 /* ~~x -> x */
 (simplify
   (bit_not (bit_not @0))
diff -Naur gcc-6.2.0.orig/gcc/tree-call-cdce.c gcc-6.2.0/gcc/tree-call-cdce.c
--- gcc-6.2.0.orig/gcc/tree-call-cdce.c	2016-12-09 13:12:37.781084124 -0800
+++ gcc-6.2.0/gcc/tree-call-cdce.c	2016-12-09 13:15:27.427873475 -0800
@@ -801,14 +801,20 @@
       if (join_tgt_in_edge_from_call == NULL)
         return false;
       free_dominance_info (CDI_DOMINATORS);
+      /* We don't want to handle PHIs. */
+      if (EDGE_COUNT (join_tgt_in_edge_from_call->dest->preds) > 1)
+        join_tgt_bb = split_edge (join_tgt_in_edge_from_call);
+      else
+        join_tgt_bb = join_tgt_in_edge_from_call->dest;
     }
   else
-    join_tgt_in_edge_from_call = split_block (bi_call_bb, bi_call);
+    {
+     join_tgt_in_edge_from_call = split_block (bi_call_bb, bi_call);
+     join_tgt_bb = join_tgt_in_edge_from_call->dest;
+    }
 
   bi_call_bsi = gsi_for_stmt (bi_call);
 
-  join_tgt_bb = join_tgt_in_edge_from_call->dest;
-
   /* Now it is time to insert the first conditional expression
      into bi_call_bb and split this bb so that bi_call is
      shrink-wrapped.  */
diff -Naur gcc-6.2.0.orig/gcc/tree-cfgcleanup.c gcc-6.2.0/gcc/tree-cfgcleanup.c
--- gcc-6.2.0.orig/gcc/tree-cfgcleanup.c	2016-12-09 13:12:37.763084042 -0800
+++ gcc-6.2.0/gcc/tree-cfgcleanup.c	2016-12-09 13:19:45.469539509 -0800
@@ -42,6 +42,7 @@
 #include "tree-scalar-evolution.h"
 #include "gimple-match.h"
 #include "gimple-fold.h"
+#include "tree-ssa-loop-niter.h"
 
 
 /* The set of blocks in that at least one of the following changes happened:
@@ -873,6 +874,18 @@
 	     DEST.  */
 	  e = single_succ_edge (split_edge (e));
 	}
+      else
+	{
+	 /* If we merge the forwarder into a loop header verify if we
+	  * are creating another loop latch edge. If so, reset
+	  * number of iteration information of the loop. */
+	 if (dest->loop_father->header == dest
+	     && dominated_by_p (CDI_DOMINATORS, e->src, dest))
+	    {
+	     dest->loop_father->any_upper_bound = false;
+	     free_numbers_of_iterations_estimates_loop (dest->loop_father);
+	    }
+	}
 
       s = redirect_edge_and_branch (e, dest);
 
diff -Naur gcc-6.2.0.orig/gcc/tree-ssa-ccp.c gcc-6.2.0/gcc/tree-ssa-ccp.c
--- gcc-6.2.0.orig/gcc/tree-ssa-ccp.c	2016-12-09 13:12:30.905052844 -0800
+++ gcc-6.2.0/gcc/tree-ssa-ccp.c	2016-12-09 13:22:34.043089424 -0800
@@ -1732,7 +1732,12 @@
     {
       fold_defer_overflow_warnings ();
       simplified = ccp_fold (stmt);
-      if (simplified && TREE_CODE (simplified) == SSA_NAME)
+      if (simplified
+          && TREE_CODE (simplified) == SSA_NAME
+          /* We may not use values of something that may be simulated again,
+             see valueize_op_1. */
+          && (SSA_NAME_IS_DEFAULT_DEF (simplified)
+            || ! prop_simulate_again_p (SSA_NAME_DEF_STMT (simplified))))
 	{
 	  val = *get_value (simplified);
 	  if (val.lattice_val != VARYING)
diff -Naur gcc-6.2.0.orig/gcc/tree-ssa-sccvn.c gcc-6.2.0/gcc/tree-ssa-sccvn.c
--- gcc-6.2.0.orig/gcc/tree-ssa-sccvn.c	2016-12-09 13:12:37.729083887 -0800
+++ gcc-6.2.0/gcc/tree-ssa-sccvn.c	2016-12-09 13:24:43.549048386 -0800
@@ -3312,6 +3312,10 @@
     {
       if (vnresult->result_vdef && vdef)
 	changed |= set_ssa_val_to (vdef, vnresult->result_vdef);
+      else if (vdef)
+	/* If the call was discovered to be pure or const reflect
+	   that as far as possible. */
+	changed |= set_ssa_val_to (vdef, vuse_ssa_val (gimple_vuse (stmt)));
 
       if (!vnresult->result && lhs)
 	vnresult->result = lhs;
